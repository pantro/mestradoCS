# -*- coding: utf-8 -*-
"""MO433-IPDI-TRABALHO_03.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16Nw3dL0sBFEIaVbCBEGXFbXPM-dxs7iV

# UNIVERSIDADE ESTADUAL DE CAMPINAS INSTITUTE OF COMPUTING

## INTRODUCTION TO DIGITAL IMAGE PROCESSING
MC920 / MO443

### HOMEWORK 3

STUDENT: Gian Franco Joel Condori Luna

RA: 234826
"""

#import necessary libraries
from google.colab import drive
drive.mount('/content/drive')
import cv2
import numpy as np
import matplotlib.pyplot as plt

#To know what files we have in this route
!ls "/content/drive/My Drive/imagenes/imagens_objetos_coloridos"

"""#1.1 Color Transformation"""

#Read imagen
img_colorida = cv2.imread("/content/drive/My Drive/imagenes/imagens_objetos_coloridos/objetos3.png")
img_monocromatica = cv2.cvtColor(img_colorida, cv2.COLOR_BGR2GRAY)

plt.subplot(121),plt.imshow(img_colorida)
plt.title('Image Colorida'), plt.xticks([]), plt.yticks([])
plt.subplot(122),plt.imshow(img_monocromatica, cmap = 'gray')
plt.title('Image Monocromatica'), plt.xticks([]), plt.yticks([])
plt.show()

from PIL import Image  
image_file = Image.open("/content/drive/My Drive/imagenes/imagens_objetos_coloridos/objetos3.png") # open colour image 
image_file= image_file.convert('L') # convert image to monochrome - this works 
image_file= image_file.convert('1') # convert image to black and white 
image_file

"""#1.2 Outlines of objects"""

#Gaussian filter to remove noise in the image
gaussian = cv2.GaussianBlur(img_monocromatica, (5,5), 0)

plt.subplot(131),plt.imshow(img_colorida)
plt.title('Image Colorida'), plt.xticks([]), plt.yticks([])
plt.subplot(132),plt.imshow(img_monocromatica, cmap = 'gray')
plt.title('Image Monocromatica'), plt.xticks([]), plt.yticks([])
plt.subplot(133),plt.imshow(gaussian, cmap = 'gray')
plt.title('Gaussian Filter'), plt.xticks([]), plt.yticks([])
plt.show()

#Calculate Canny Edge Detector with OpenCV
canny = cv2.Canny(gaussian, 50, 150)
plt.imshow(canny, cmap = 'gray')

"""#1.3 Object properties extraction"""

# We look for the contours
(contours,_) = cv2.findContours(canny.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

cv2.drawContours(img_colorida,contours,-1,(0,255,0), 2)
plt.imshow(img_colorida)

#Count each contour and put a number on it
img = img_colorida.copy()
font = cv2.FONT_HERSHEY_SIMPLEX
i = -1
print("Número de regiones: "+str(len(contours)))
for c in contours:
  #Finding central coordinates of each element
  M = cv2.moments(c)
  if(M["m00"]==0):M["m00"]=1
  x = int(M["m10"]/M["m00"])
  y = int(M["m01"]/M["m00"])
  #Message
  message = str(i+1)
  cv2.putText(img, message, (x-5,y+5), font, 0.4, (255,255,255), 2, cv2.LINE_AA)
  cv2.drawContours(img,[c],-1,(0,255,0), 2)
  #Area
  area = cv2.contourArea(c)
  #Perimeter
  perimeter = cv2.arcLength(c,True)
  #
  #Eccentricity
  ellipse = cv2.fitEllipse(c)
  #center, axis_length and orientation of ellipse
  (center, axes, orientation) = ellipse
  # length of MAJOR and minor axis
  majoraxis_length = max(axes)
  minoraxis_length = min(axes)
  # eccentricity = sqrt( 1 - (ma/MA)^2) --- ma= minor axis --- MA= major axis
  eccentricity = np.sqrt(1-(minoraxis_length/majoraxis_length)**2)
  #
  #Solidity
  # convex hull
  convex_hull = cv2.convexHull(c)
  # convex hull area
  convex_area = cv2.contourArea(convex_hull)
  # solidity = contour area / convex hull area
  solidity = area/float(convex_area)

  #Result
  print("Region "+ mensaje+": area:"+str(area)+"  perimeter:"+str(perimeter)+"  eccentricity:"+str(eccentricity)+"  solidity:"+str(solidity))

  i = i+1
plt.imshow(img)

"""#1.4 Area Histogram of Objects"""

areas = []
cant_pequeno = 0
cant_medio = 0
cant_grande = 0
for c in contours:
  #Area
  area = cv2.contourArea(c)
  areas.append(area)#accumulator
  if (area < 1500):
    cant_pequeno = cant_pequeno+1
  elif (area >= 1500 and area < 3000):
    cant_medio = cant_medio+1
  else :
    cant_grande = cant_grande+1

print("Numero de regiones pequenas:"+str(cant_pequeno))
print("Numero de regiones medianas:"+str(cant_medio))
print("Numero de regiones grandes:"+str(cant_grande))

#Histogram
intervalos = [0, 1500, 3000, 4500] #calculamos los extremos de los intervalos

plt.hist(x=areas, bins=intervalos, color='#F2AB6D', rwidth=0.85)
plt.title('Histograma de áreas dos objetos')
plt.xlabel('Área')
plt.ylabel('Número objetos')
plt.xticks(intervalos)

plt.show() #dibujamos el histograma
# -*- coding: utf-8 -*-
"""MO433-IPDI-TRABALHO_02.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zvrP_SOc9Nq1HNiRvFGSfRDnyXccGk57

# UNIVERSIDADE ESTADUAL DE CAMPINAS INSTITUTE OF COMPUTING

## INTRODUCTION TO DIGITAL IMAGE PROCESSING
MC920 / MO443

### HOMEWORK 2

STUDENT: Gian Franco Joel Condori Luna
RA: 234826
"""

#import necessary libraries
from google.colab import drive
drive.mount('/content/drive')
import cv2
import numpy as np
import matplotlib.pyplot as plt

#To know what files we have in this route
!ls "/content/drive/My Drive/imagenes/imagens_png"

"""##Fast Fourier Transform"""

#Read imagen
img = cv2.imread("/content/drive/My Drive/imagenes/imagens_png/baboon.png",0)

f = np.fft.fft2(img)

fshift = np.fft.fftshift(f)
magnitude_spectrum = np.log(np.abs(fshift))

plt.subplot(121),plt.imshow(img, cmap = 'gray')
plt.title('Input Image'), plt.xticks([]), plt.yticks([])
plt.subplot(122),plt.imshow(magnitude_spectrum, cmap = 'gray')
plt.title('Magnitude Spectrum'), plt.xticks([]), plt.yticks([])
plt.show()

"""##Inverse Fast Fourier Transform (IFFT)"""

f_ishift = np.fft.ifftshift(fshift)
idft = np.fft.ifft2(f_ishift)
img_back = np.log(np.abs(idft))
img_back = np.where(img_back < 0, 0, img_back)
#Graph image
plt.subplot(121),plt.imshow(magnitude_spectrum, cmap = 'gray')
plt.title('Magnitude Spectrum'), plt.xticks([]), plt.yticks([])
plt.subplot(1,2,2),plt.imshow(img_back, cmap = 'gray')
plt.title('Input result'), plt.xticks([]), plt.yticks([])
plt.show()

"""##Low Pass Filter (LPF)"""

#Function Low Pass Filter
def LowPassFilter (magnitude_spectrum, radius):
  #Dimensions
  rows, cols = magnitude_spectrum.shape # (512, 512)
  #Center the image
  crow, ccol = int(rows / 2), int(cols / 2) #(256, 256)
  #Mask of one
  mask_pb = np.ones((rows, cols), np.uint8) # (512, 512, 2)
  #center
  center = [crow, ccol]
  x, y = np.ogrid[:rows, :cols] # 0 to 511
  #If they are outside the radius it is TRUE
  mask_area_pb = (x - center[0]) ** 2 + (y - center[1]) ** 2 > radius*radius
  #Zeroing everything TRUE
  mask_pb[mask_area_pb] = 0 
  #Multiplying
  complex_pb = mask_pb*fshift
  result_pb = magnitude_spectrum*mask_pb

  return result_pb, mask_pb, complex_pb

#Run function
result_pb, mask_pb, complex_pb = LowPassFilter (magnitude_spectrum, 100)
#Graph image
plt.subplot(121),plt.imshow(mask_pb, cmap = 'gray')
plt.title('Input Mask'), plt.xticks([]), plt.yticks([])
plt.subplot(122),plt.imshow(result_pb, cmap = 'gray')
plt.title('Input Result'), plt.xticks([]), plt.yticks([])
plt.show()

#Test radius
#Run function
result_pb, mask_pb, complex_pb = LowPassFilter (magnitude_spectrum, 10)
#Inverse
f_ishift = np.fft.ifftshift(complex_pb)
idft = np.fft.ifft2(f_ishift)
img_back = np.log(np.abs(idft))
img_back = np.where(img_back < 0, 0, img_back)
#Graph image
plt.subplot(131),plt.imshow(img, cmap = 'gray')
plt.title('Input Img'), plt.xticks([]), plt.yticks([])
plt.subplot(132),plt.imshow(result_pb, cmap = 'gray')
plt.title('Input Result'), plt.xticks([]), plt.yticks([])
plt.subplot(133),plt.imshow(img_back, cmap = 'gray')
plt.title('Input Result'), plt.xticks([]), plt.yticks([])
plt.show()

"""##High Pass Filter (HPF)"""

#Function High Pass Filter
def HighPassFilter (magnitude_spectrum, radius):
  #Dimensions
  rows, cols = magnitude_spectrum.shape # (512, 512)
  #Center the image
  crow, ccol = int(rows / 2), int(cols / 2) #(256, 256)
  #Mask of one
  mask_pa = np.ones((rows, cols), np.uint8) # (512, 512, 2)
  #center
  center = [crow, ccol]
  x, y = np.ogrid[:rows, :cols] # 0 to 511
  #If they are within the radius it is TRUE
  mask_area_pa = (x - center[0]) ** 2 + (y - center[1]) ** 2 <= radius*radius
  #Zeroing everything TRUE
  mask_pa[mask_area_pa] = 0 
  #Multiplying
  complex_pa = mask_pa*fshift
  result_pa = magnitude_spectrum*mask_pa

  return result_pa, mask_pa, complex_pa

#Run function
result_pa, mask_pa, complex_pa = HighPassFilter (magnitude_spectrum, 100)
#graph image
plt.subplot(121),plt.imshow(mask_pa, cmap = 'gray')
plt.title('Input Mask'), plt.xticks([]), plt.yticks([])
plt.subplot(122),plt.imshow(result_pa, cmap = 'gray')
plt.title('Input result'), plt.xticks([]), plt.yticks([])
plt.show()

#Test radius
#Run function
result_pa, mask_pa, complex_pa = HighPassFilter (magnitude_spectrum, 10)
#Inverse
f_ishift = np.fft.ifftshift(complex_pa)
idft = np.fft.ifft2(f_ishift)
img_back = np.log(np.abs(idft))
img_back = np.where(img_back < 0, 0, img_back)
#Graph image
plt.subplot(131),plt.imshow(img, cmap = 'gray')
plt.title('Input Img'), plt.xticks([]), plt.yticks([])
plt.subplot(132),plt.imshow(result_pa, cmap = 'gray')
plt.title('Input Result'), plt.xticks([]), plt.yticks([])
plt.subplot(133),plt.imshow(img_back, cmap = 'gray')
plt.title('Input Result'), plt.xticks([]), plt.yticks([])
plt.show()

"""## Band Pass Filter (BPF)"""

#Function Band Pass Filter
def BandPassFilter (magnitude_spectrum, radius_minor, radius_major):
  #Dimensions
  rows, cols = magnitude_spectrum.shape # (512, 512)
  #Center the image
  crow, ccol = int(rows / 2), int(cols / 2) #(256, 256)
  #Mask of one
  mask_pf = np.ones((rows, cols), np.uint8) # (512, 512, 2)
  #center
  center = [crow, ccol]
  x, y = np.ogrid[:rows, :cols] # 0 to 511
  #All those that are less than the minor radius or all those that are greater than the major radius is TRUE
  mask_area_pf = ((x - center[0]) ** 2 + (y - center[1]) ** 2 <= radius_minor*radius_minor)+((x - center[0]) ** 2 + (y - center[1]) ** 2 > radius_major*radius_major)
  #Zeroing everything TRUE
  mask_pf[mask_area_pf] = 0 
  #Multiplying
  complex_pf = mask_pf*fshift
  result_pf = magnitude_spectrum*mask_pf

  return result_pf, mask_pf, complex_pf

#Run function
result_pf, mask_pf, complex_pf = BandPassFilter (magnitude_spectrum, 30, 100)
#graph image
plt.subplot(121),plt.imshow(mask_pf, cmap = 'gray')
plt.title('Input Mask'), plt.xticks([]), plt.yticks([])
plt.subplot(122),plt.imshow(result_pf, cmap = 'gray')
plt.title('Input result'), plt.xticks([]), plt.yticks([])
plt.show()

#Test radius
#Run function
result_pf, mask_pf, complex_pf = BandPassFilter (magnitude_spectrum, 5, 10)
#Inverse
f_ishift = np.fft.ifftshift(complex_pf)
idft = np.fft.ifft2(f_ishift)
img_back = np.log(np.abs(idft))
img_back = np.where(img_back < 0, 0, img_back)
#Graph image
plt.subplot(131),plt.imshow(img, cmap = 'gray')
plt.title('Input Img'), plt.xticks([]), plt.yticks([])
plt.subplot(132),plt.imshow(result_pf, cmap = 'gray')
plt.title('Input Result'), plt.xticks([]), plt.yticks([])
plt.subplot(133),plt.imshow(img_back, cmap = 'gray')
plt.title('Input Result'), plt.xticks([]), plt.yticks([])
plt.show()

"""##Rotating an image"""

def RotatingImg (img):
  srcTri = np.array( [[0, 0], [img.shape[1] - 1, 0], [0, img.shape[0] - 1]] ).astype(np.float32)
  #Here we decide that the angle of rotation is 45
  dstTri = np.array( [[0, img.shape[1]*0.5], [img.shape[1]*0.5, 0], [img.shape[1]*0.5, img.shape[0]*1]] ).astype(np.float32)
  
  warp_mat = cv2.getAffineTransform(srcTri, dstTri)
  warp_dst = cv2.warpAffine(img, warp_mat, (img.shape[1], img.shape[0]))

  return warp_dst
  
#Run function
warp_dst = RotatingImg(img)
#graph image
plt.subplot(1,2,1),plt.imshow(img, cmap = 'gray')
plt.title('Input img'), plt.xticks([]), plt.yticks([])
plt.subplot(1,2,2),plt.imshow(warp_dst, cmap = 'gray')
plt.title('Input result'), plt.xticks([]), plt.yticks([])
plt.show()